require 'minitest/autorun'
require_relative 'dnd_character'

module Helpers
  BASE_HITPOINTS = 10

  def attributes
    %i[strength dexterity constitution intelligence wisdom charisma]
  end
end

class DndCharacterTest < Minitest::Test
  include Helpers
<% json["cases"].each do |cases| %>
    <% if cases.key?("cases")%>

        <% cases["cases"].each do |sub_case| %>
            def test_<%= underscore(sub_case["description"]) %>
                <%= skip? %>
                <%- if sub_case["property"] == "modifier" -%>
                assert_equal(<%= sub_case["expected"] %>, DndCharacter.modifier(<%= sub_case["input"]["score"] %>))
                <%- end -%>
            end
        <% end %>
    <% end %>
<% end %>
    # rubocop:disable Style/FormatString, Style/RedundantPercentQ
  def test_random_character_stats
    skip
    100.times do
      character = DndCharacter.new
      allowed_range = (3..18)
      expected_hitpoints = BASE_HITPOINTS +
                           DndCharacter.modifier(character.constitution)
      informative_message = %q(The character's %s must be within %s)

      attributes.each do |attribute|
        assert_includes allowed_range, character.send(attribute),
          informative_message % [attribute, allowed_range]
      end

      informative_message = %q(The character's %s must be %s)

      assert_equal expected_hitpoints, character.hitpoints,
        informative_message % ['hitpoints', expected_hitpoints]
    end
  end

  def test_stats_calculated_once
    skip
    informative_message = <<~EXPLAIN
      The character's %<attribute>s must not change if called more than once.
      It was %<first>s, is now %<second>s.
    EXPLAIN

    100.times do
      character = DndCharacter.new

      (attributes << :hitpoints).each do |attribute|
        first = character.send(attribute)
        second = character.send(attribute)

        assert_equal first, second,
          informative_message % { attribute:, first:, second: }
      end
    end
    # rubocop:enable Style/FormatString, Style/RedundantPercentQ
  end
end